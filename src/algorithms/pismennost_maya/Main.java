package algorithms.pismennost_maya;

import java.util.*;

/** Расшифровка письменности Майя.
 Письменность Майя основывается на маленьких рисунках, известных как значки, которые
 обозначают звуки. Слова языка Майя обычно записываются с помощью этих значков, которые
 располагаются рядом друг с другом в некотором порядке.
 Одна из проблем расшифровки письменности Майя заключается в определении этого порядка.
 Рисуя значки некоторого слова, писатели Майя иногда выбирали позиции для значков, исходя скорее
 из эстетических взглядов, а не определенных правил. Это привело к тому, что, хотя звуки для многих
 значков известны, археологи не всегда уверены, как должно произноситься записанное слово.
 Археологи ищут некоторое слово W. Они знают n значков, составляющих слово W, и
 последовательность S всех значков в надписи, которую они изучают. Требуется подсчитать
 количество возможных появлений слова W.
 Напишите программу, которая по значкам слова W и по последовательности S значков
 надписи подсчитывает количество всех возможных вхождений слова W в S; то есть количество всех
 различных позиций идущих подряд n значков в последовательности S, которые являются какой-либо
 перестановкой значков слова W.
 */
public class Main {

    public static int getRepeats(List<String> symSeq, List<String> sortWord){
        int count = 0;

        /** Проход по всей последовательности символов */
        for (int i = 0; i < symSeq.size(); i++) {

            /** Если последний индекс перешагнёт за пределы списка то выйти */
            if (sortWord.size() + i == symSeq.size()) return count;

            /** Проход по последовательности на длину слова */
            String[] newWord = new String[sortWord.size()];
            int index = 0;
            for (int j = i; j < sortWord.size() + i; j++) {
                /** Если последовательность содержит символ */
                if (sortWord.contains(symSeq.get(j))) {
                    /** То добавим его в проверочное слово */
                    newWord[index] = symSeq.get(j);
                /** Иначе перейдём к другому символу и заново начнём проверку */
                } else break;
                index++;
            }
            /** Сортировка массива букв и формирование в целую строку */
            final String[] temp1 = {""};
            Arrays.stream(newWord).sorted().forEach(s -> temp1[0] += s);
            System.out.println("temp1[0]: " + temp1[0]);
            // отсоритровать строки и сравнить с входной строкой, посчитать совпадения и вернуть результат

            /** Сортировка проверочного слова и формирование его в целую строку */
            final String[] temp2 = {""};
            sortWord.stream().sorted().forEach(s -> temp2[0] += s);
            System.out.println("temp2[0]: " + temp2[0]);

            /** Считаем количество совпадений отсортированных пачек символов с проверочным словом */
            if (temp2[0].equals(temp1[0])) {
                count++;
            }
        }
        return count;
    }

    public static void main(String[] args) {
        /** Символы */
        List<String> symSeq = Arrays.asList("u", "n", "s", "u", "n", "n", "u", "s");
        /** Слово */
        List<String> word = Arrays.asList("s", "u", "n");

       // sortWord.stream().forEach(System.out::println);

        int res = getRepeats(symSeq, word);
        System.out.println("res: " + res);

        String[] arr = {"u", "n", "s", "u", "n", "n", "u", "s"};
        final String[] str = {""};
        Arrays.stream(arr).sorted().forEach(s -> str[0] += s);
        System.out.println(str[0]);


    }
}
