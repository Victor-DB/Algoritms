package algorithms.metro;

import java.util.Random;

/** На некоторых кросс-платформенных станциях метро(как, например "Третьяковская") на разные
 * стороны платформы приходят поезда разных направлений. Таня договорилась встретиться с
 * подругой на такой станции, но поскольку подруга приехала из другого часового пояса,
 * то из-за джетлага сильно проспала, и Тане пришлось долго её ждать. Поезда всегда ходят по
 * расписанию, и Таня знает, что поезд стоит на платформе ровно одну минуту, а интервал между
 * поездами (время в течение которого поезда у платформы нет) составляет а минут для поездов
 * на первом пути и b минут для поездов на втором пути. То есть на первый путь приезжает поезд
 * и стоит одну минуту, затем в течение а минут поезда у платформы нет, затем в течение минуты
 * у платформы стоит следующий поезд и т.д.
 *
 * Пока Таня стояла на платформе, она насчитала n поездов на первом пути и m поездов на втором пути.
 * Определите минимальное и максимальное время, которое Таня могла провести на платформе, или сообщите,
 * что она точно сбилась со счёта.
 *
 * Все поезда, которые видела Таня, она наблюдала в течение всей минуты, то есть Таня не приходит и не уходит
 * с платформы посередине той минуты, когда поезд стоит на платформе.
 * */


public class Main {

    static int randomRange(int min, int max) {
        Random random = new Random();
        int res = random.nextInt(max) + 1;
        if (res < min) {
           return randomRange(min, max);
        }
        return res;
    }

    static int minTime(int n, int a, int m, int b){
        /** Минимальное время ожидания поездов с первой платформы
         * То есть если Таня застала 3 поезда и 2 остановки ( например )
         * */
        int t1Min = (n - 1) * a + n * 1;
        /** Минимальное время ожидания поездов со второй платформы
         * То есть если Таня застала 3 поезда и 4 остановки ( например )
         * */
        int t2Min = (m - 1) * b + n * 1;
        // [min1  [min2   max1]   max2}   =>  чтобы гарантированно увидеть минимум нужно взять Math.max(t1Min, t2Min) т.е. min2
        System.out.println("Минимальное кол-во поездов: " + Math.max(t1Min, t2Min));
        return Math.max(t1Min, t2Min);
    }

    static int maxTime(int n, int a, int m, int b) {
        /** Максимальное время ожидания поездов с первой платформы
         * t1Min + 2a
         * */
        int t1Max = (n - 1) * a + n * 1 + 2 * a;
        /** Максимальное время ожидания поездов со второй платформы
         * t2Min + 2a
         * */
        int t2Max = (m - 1) * b + n * 1 + 2 * a;
        // [min1  [min2   max1]   max2]   =>  чтобы гарантированно увидеть максимум нужно взять Math.min(t1Max, t2Max) т.е. max1
        System.out.println("Максимальное кол-во поездов: " + Math.min(t1Max, t2Max));
        return Math.max(t1Max, t2Max);
    }

    static void sbilasSoSchetu(int n, int a, int m, int b){

        if (maxTime(n, a, m, b) > minTime(n, a, m, b)) {
            System.out.println("Таня сбилась со счёта");
        }

    }

    public static void main(String[] args) {
        int n = randomRange(7, 8);
        int a = randomRange(2, 3);
        int m = randomRange(7, 8);
        int b = randomRange(2, 3);;
        System.out.printf("\n n: %d\n a: %d\n m: %d\n b: %d\n", n, a, m, b);

        minTime(n, a, m, b);
        maxTime(n, a, m, b);
        sbilasSoSchetu(n, a, m, b);
    }
}
